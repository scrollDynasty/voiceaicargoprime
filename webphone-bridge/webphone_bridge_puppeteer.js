/**
 * RingCentral WebPhone Bridge with Puppeteer
 * Uses real browser with WebRTC support
 */

require('dotenv').config();
const puppeteer = require('puppeteer');
const express = require('express');
const WebSocket = require('ws');
const winston = require('winston');
const axios = require('axios');
const path = require('path');
const fs = require('fs');

// –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
const logger = winston.createLogger({
    level: process.env.LOG_LEVEL || 'info',
    format: winston.format.combine(
        winston.format.timestamp(),
        winston.format.printf(({ timestamp, level, message }) => {
            return `${timestamp} [${level.toUpperCase()}] ${message}`;
        })
    ),
    transports: [
        new winston.transports.Console(),
        new winston.transports.File({ filename: 'webphone-puppeteer.log' })
    ]
});

// –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
const config = {
    clientId: process.env.RINGCENTRAL_CLIENT_ID || 'bXCZ510zNmybxAUXGIZruT',
    clientSecret: process.env.RINGCENTRAL_CLIENT_SECRET || '10hW9ccNfhyc1y69bQzdgnVUnFyf76B6qcmwOtypEGo7',
    jwtToken: process.env.RINGCENTRAL_JWT_TOKEN || 'eyJraWQiOiI4NzYyZjU5OGQwNTk0NGRiODZiZjVjYTk3ODA0NzYwOCIsInR5cCI6IkpXVCIsImFsZyI6IlJTMjU2In0.eyJhdWQiOiJodHRwczovL3BsYXRmb3JtLnJpbmdjZW50cmFsLmNvbS9yZXN0YXBpL29hdXRoL3Rva2VuIiwic3ViIjoiMjA2OTkwOTAxOSIsImlzcyI6Imh0dHBzOi8vcGxhdGZvcm0ucmluZ2NlbnRyYWwuY29tIiwiZXhwIjozOTAzNjUxMzQyLCJpYXQiOjE3NTYxNjc2OTUsImp0aSI6IlpTckJuOHlFVDJLeEFjOXhmTlZ6ZncifQ.fHF6mXLa9wHygLYiFVQzIo4bKT8niwnYKD7PT7gFGoayZpDOkHwamesmXunn_IIY3rRT9Z2hXHgaJpdpW5ZRimaYOydcjGpj1HgdOxmTRBcYj6B4HWXb9YXO95Q2sfFLPS-3DwvcxeqNW8yoX3Cx31VpCfsybrvwq1NtDO73KulJYPByTSjoLQMj5to5gxRtKlqbhabj1o4YaeKkKb70_Sr-T0lXQS_93fOaPi0xP_AYNhDmDEQBZc1tvwUF7-ETj2Bv-EnfH5OxWfbRS3bSnZdRs1P-0TJg6SfNgwlAGNnMqEdpVyBMXt-02aQA8xgo1O9RDI-nSUXd2iKaA5CTAg',
    server: process.env.RINGCENTRAL_SERVER || 'https://platform.ringcentral.com',
    pythonServer: process.env.PYTHON_AI_SERVER || 'http://localhost:5000',
    wsPort: 8082, // WebSocket port for browser communication
    webhookPort: 8081, // Port for webhook events from Python
    headless: process.env.HEADLESS !== 'false', // Run in headless mode by default
};

// –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
let browser = null;
let page = null;
let wsServer = null;
let webhookWsServer = null;
let browserWsConnection = null;
let activeCalls = new Map();
let audioBuffer = [];

// –ó–∞–ø—É—Å–∫ Express —Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è –æ–±—Å–ª—É–∂–∏–≤–∞–Ω–∏—è HTML —Ñ–∞–π–ª–æ–≤
function startHTTPServer() {
    const app = express();
    app.use(express.static(path.join(__dirname)));
    
    const server = app.listen(0, () => {
        const port = server.address().port;
        logger.info(`üìÅ HTTP server started on port ${port}`);
        return port;
    });
    
    return server;
}

// –ó–∞–ø—É—Å–∫ WebSocket —Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è —Å–≤—è–∑–∏ —Å –±—Ä–∞—É–∑–µ—Ä–æ–º
function startWebSocketServer() {
    wsServer = new WebSocket.Server({ port: config.wsPort });
    
    wsServer.on('connection', (ws) => {
        logger.info('‚úÖ Browser WebSocket connected');
        browserWsConnection = ws;
        
        ws.on('message', (message) => {
            try {
                // Check if message is binary (audio data)
                if (message instanceof Buffer) {
                    handleAudioData(message);
                } else {
                    const data = JSON.parse(message);
                    handleBrowserMessage(data);
                }
            } catch (error) {
                logger.error(`‚ùå Failed to process browser message: ${error.message}`);
            }
        });
        
        ws.on('close', () => {
            logger.warn('‚ö†Ô∏è Browser WebSocket disconnected');
            browserWsConnection = null;
        });
        
        ws.on('error', (error) => {
            logger.error(`‚ùå Browser WebSocket error: ${error.message}`);
        });
    });
    
    logger.info(`üåê WebSocket server for browser started on port ${config.wsPort}`);
}

// –ó–∞–ø—É—Å–∫ WebSocket —Å–µ—Ä–≤–µ—Ä–∞ –¥–ª—è webhook —Å–æ–±—ã—Ç–∏–π –æ—Ç Python
function startWebhookServer() {
    webhookWsServer = new WebSocket.Server({ port: config.webhookPort });
    
    webhookWsServer.on('connection', (ws) => {
        logger.info('‚úÖ Python webhook WebSocket connected');
        
        ws.on('message', (message) => {
            try {
                const data = JSON.parse(message);
                handleWebhookEvent(data);
            } catch (error) {
                logger.error(`‚ùå Failed to process webhook: ${error.message}`);
            }
        });
    });
    
    logger.info(`üåê WebSocket server for webhooks started on port ${config.webhookPort}`);
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –æ—Ç –±—Ä–∞—É–∑–µ—Ä–∞
function handleBrowserMessage(data) {
    switch (data.type) {
        case 'log':
            logger.info(`[Browser] ${data.message}`, data.data || {});
            break;
            
        case 'status':
            logger.info(`üìä WebPhone status: ${data.status}`);
            break;
            
        case 'incomingCall':
            logger.info(`üìû Incoming call from ${data.from} to ${data.to}`);
            activeCalls.set(data.sessionId, {
                sessionId: data.sessionId,
                from: data.from,
                to: data.to,
                startTime: Date.now()
            });
            // –£–≤–µ–¥–æ–º–∏—Ç—å Python —Å–µ—Ä–≤–µ—Ä –æ –≤—Ö–æ–¥—è—â–µ–º –∑–≤–æ–Ω–∫–µ
            notifyPythonServer('incoming_call', data);
            break;
            
        case 'callEnded':
            logger.info(`üìû Call ended: ${data.sessionId}`);
            activeCalls.delete(data.sessionId);
            // –£–≤–µ–¥–æ–º–∏—Ç—å Python —Å–µ—Ä–≤–µ—Ä –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –∑–≤–æ–Ω–∫–∞
            notifyPythonServer('call_ended', data);
            // –û—á–∏—Å—Ç–∏—Ç—å –∞—É–¥–∏–æ –±—É—Ñ–µ—Ä
            audioBuffer = [];
            break;
            
        default:
            logger.warn(`Unknown message type from browser: ${data.type}`);
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—É–¥–∏–æ –¥–∞–Ω–Ω—ã—Ö –æ—Ç –±—Ä–∞—É–∑–µ—Ä–∞
function handleAudioData(audioData) {
    // –î–æ–±–∞–≤–∏—Ç—å –≤ –±—É—Ñ–µ—Ä
    audioBuffer.push(audioData);
    
    // –û—Ç–ø—Ä–∞–≤–∏—Ç—å –∞—É–¥–∏–æ –≤ Python —Å–µ—Ä–≤–µ—Ä –∫–æ–≥–¥–∞ –Ω–∞–∫–æ–ø–∏—Ç—Å—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö
    if (audioBuffer.length >= 10) { // ~160ms –ø—Ä–∏ 16kHz
        sendAudioToPython();
    }
}

// –û—Ç–ø—Ä–∞–≤–∫–∞ –∞—É–¥–∏–æ –≤ Python —Å–µ—Ä–≤–µ—Ä
async function sendAudioToPython() {
    if (audioBuffer.length === 0) return;
    
    try {
        // –û–±—ä–µ–¥–∏–Ω–∏—Ç—å –≤—Å–µ –∞—É–¥–∏–æ —Ñ—Ä–∞–≥–º–µ–Ω—Ç—ã
        const combinedBuffer = Buffer.concat(audioBuffer);
        audioBuffer = []; // –û—á–∏—Å—Ç–∏—Ç—å –±—É—Ñ–µ—Ä
        
        // –û—Ç–ø—Ä–∞–≤–∏—Ç—å –≤ Python —Å–µ—Ä–≤–µ—Ä
        const response = await axios.post(
            `${config.pythonServer}/api/process-audio`,
            combinedBuffer,
            {
                headers: {
                    'Content-Type': 'audio/raw',
                    'X-Sample-Rate': '16000',
                    'X-Channels': '1',
                    'X-Encoding': 'pcm16'
                }
            }
        );
        
        if (response.data && response.data.response_audio) {
            // TODO: –û—Ç–ø—Ä–∞–≤–∏—Ç—å –æ—Ç–≤–µ—Ç–Ω–æ–µ –∞—É–¥–∏–æ –æ–±—Ä–∞—Ç–Ω–æ –≤ –±—Ä–∞—É–∑–µ—Ä –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è
            logger.info('üéµ Received response audio from Python');
        }
        
    } catch (error) {
        logger.error(`‚ùå Failed to send audio to Python: ${error.message}`);
    }
}

// –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ Python —Å–µ—Ä–≤–µ—Ä–∞ –æ —Å–æ–±—ã—Ç–∏—è—Ö
async function notifyPythonServer(event, data) {
    try {
        await axios.post(
            `${config.pythonServer}/api/webphone-event`,
            {
                event,
                data,
                timestamp: new Date().toISOString()
            }
        );
    } catch (error) {
        logger.error(`‚ùå Failed to notify Python server: ${error.message}`);
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ webhook —Å–æ–±—ã—Ç–∏–π –æ—Ç Python
function handleWebhookEvent(data) {
    logger.info(`üì® Webhook event from Python: ${data.event || data.uuid}`);
    
    // –ü–µ—Ä–µ—Å—ã–ª–∞–µ–º —Å–æ–±—ã—Ç–∏–µ –≤ –±—Ä–∞—É–∑–µ—Ä –µ—Å–ª–∏ –Ω—É–∂–Ω–æ
    if (browserWsConnection && browserWsConnection.readyState === WebSocket.OPEN) {
        browserWsConnection.send(JSON.stringify({
            type: 'webhook',
            data
        }));
    }
}

// –ó–∞–ø—É—Å–∫ Puppeteer –±—Ä–∞—É–∑–µ—Ä–∞
async function launchBrowser() {
    logger.info('üöÄ Launching Puppeteer browser...');
    
    try {
        browser = await puppeteer.launch({
            headless: config.headless ? 'new' : false,
            args: [
                '--use-fake-ui-for-media-stream',
                '--use-fake-device-for-media-stream',
                '--allow-file-access',
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage',
                '--disable-web-security',
                '--autoplay-policy=no-user-gesture-required'
            ]
        });
        
        page = await browser.newPage();
        
        // –í–∫–ª—é—á–∏—Ç—å –∫–æ–Ω—Å–æ–ª—å–Ω—ã–µ –ª–æ–≥–∏
        page.on('console', msg => {
            const type = msg.type();
            const text = msg.text();
            if (type === 'error') {
                logger.error(`[Browser Console] ${text}`);
            } else {
                logger.info(`[Browser Console] ${text}`);
            }
        });
        
        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        page.on('pageerror', error => {
            logger.error(`[Browser Error] ${error.message}`);
        });
        
        // –†–∞–∑—Ä–µ—à–∏—Ç—å –¥–æ—Å—Ç—É–ø –∫ –º–∏–∫—Ä–æ—Ñ–æ–Ω—É
        const context = browser.defaultBrowserContext();
        await context.overridePermissions('http://localhost', ['microphone']);
        
        logger.info('‚úÖ Browser launched successfully');
        
    } catch (error) {
        logger.error(`‚ùå Failed to launch browser: ${error.message}`);
        throw error;
    }
}

// –ó–∞–≥—Ä—É–∑–∫–∞ WebPhone –≤ –±—Ä–∞—É–∑–µ—Ä–µ
async function loadWebPhone(httpPort) {
    logger.info('üìÑ Loading WebPhone page...');
    
    try {
        // –ó–∞–≥—Ä—É–∑–∏—Ç—å HTML —Å—Ç—Ä–∞–Ω–∏—Ü—É
        await page.goto(`http://localhost:${httpPort}/webphone.html`, {
            waitUntil: 'networkidle0'
        });
        
        // –ò–Ω–∂–µ–∫—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        await page.evaluate((config) => {
            window.RINGCENTRAL_CONFIG = {
                clientId: config.clientId,
                clientSecret: config.clientSecret,
                jwtToken: config.jwtToken,
                server: config.server
            };
        }, config);
        
        logger.info('‚úÖ WebPhone page loaded and configured');
        
        // –ñ–¥–∞—Ç—å –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ WebPhone
        await page.waitForFunction(
            () => document.getElementById('status').textContent.includes('Ready') || 
                 document.getElementById('status').textContent.includes('Registered'),
            { timeout: 30000 }
        );
        
        logger.info('‚úÖ WebPhone initialized and ready');
        
    } catch (error) {
        logger.error(`‚ùå Failed to load WebPhone: ${error.message}`);
        
        // –°–¥–µ–ª–∞—Ç—å —Å–∫—Ä–∏–Ω—à–æ—Ç –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏
        if (page) {
            await page.screenshot({ path: 'webphone-error.png' });
            logger.info('üì∏ Screenshot saved to webphone-error.png');
        }
        
        throw error;
    }
}

// –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞
async function main() {
    logger.info('üéØ Starting RingCentral WebPhone Bridge with Puppeteer...');
    logger.info('üìã Configuration:');
    logger.info(`   Client ID: ${config.clientId.substring(0, 10)}...`);
    logger.info(`   Server: ${config.server}`);
    logger.info(`   Python Server: ${config.pythonServer}`);
    logger.info(`   Headless: ${config.headless}`);
    
    try {
        // –ó–∞–ø—É—Å—Ç–∏—Ç—å HTTP —Å–µ—Ä–≤–µ—Ä
        const httpServer = startHTTPServer();
        const httpPort = httpServer.address().port;
        
        // –ó–∞–ø—É—Å—Ç–∏—Ç—å WebSocket —Å–µ—Ä–≤–µ—Ä—ã
        startWebSocketServer();
        startWebhookServer();
        
        // –ó–∞–ø—É—Å—Ç–∏—Ç—å –±—Ä–∞—É–∑–µ—Ä
        await launchBrowser();
        
        // –ó–∞–≥—Ä—É–∑–∏—Ç—å WebPhone
        await loadWebPhone(httpPort);
        
        logger.info('‚úÖ WebPhone Bridge with Puppeteer started successfully!');
        logger.info('üéØ Waiting for incoming calls...');
        
        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è
        setInterval(async () => {
            if (page && !page.isClosed()) {
                const status = await page.evaluate(() => {
                    return document.getElementById('status').textContent;
                });
                logger.info(`ü©∫ Health check - Status: ${status}, Active calls: ${activeCalls.size}`);
            }
        }, 30000);
        
    } catch (error) {
        logger.error(`‚ùå Failed to start WebPhone Bridge: ${error.message}`);
        await cleanup();
        process.exit(1);
    }
}

// –û—á–∏—Å—Ç–∫–∞ —Ä–µ—Å—É—Ä—Å–æ–≤
async function cleanup() {
    logger.info('üßπ Cleaning up...');
    
    if (browser) {
        await browser.close();
    }
    
    if (wsServer) {
        wsServer.close();
    }
    
    if (webhookWsServer) {
        webhookWsServer.close();
    }
}

// –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–∏–≥–Ω–∞–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è
process.on('SIGINT', async () => {
    logger.info('üõë SIGINT received, shutting down...');
    await cleanup();
    process.exit(0);
});

process.on('SIGTERM', async () => {
    logger.info('üõë SIGTERM received, shutting down...');
    await cleanup();
    process.exit(0);
});

// –ó–∞–ø—É—Å–∫
main().catch(async (error) => {
    logger.error(`‚ùå Fatal error: ${error.message}`);
    await cleanup();
    process.exit(1);
});